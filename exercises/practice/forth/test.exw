include forth.e 

constant tests = {
{"numbers just get pushed onto the stack",{"1 2 3 4 5"},{1,2,3,4,5},""},
{"pushes negative numbers onto the stack",{"-1 -2 -3 -4 -5"},{-1,-2,-3,-4,-5},""},
{"can add two numbers",{"1 2 +"},{3},""},
{"errors if there is nothing on the stack",{"+"},{},"empty stack"},
{"errors if there is only one value on the stack",{"1 +"},{},"only one value on the stack"},
{"can subtract two numbers",{"3 4 -"},{-1},""},
{"errors if there is nothing on the stack",{"-"},{},"empty stack"},
{"errors if there is only one value on the stack",{"1 -"},{},"only one value on the stack"},
{"can multiply two numbers",{"2 4 *"},{8},""},
{"errors if there is nothing on the stack",{"*"},{},"empty stack"},
{"errors if there is only one value on the stack",{"1 *"},{},"only one value on the stack"},
{"can divide two numbers",{"12 3 /"},{4},""},
{"performs integer division",{"8 3 /"},{2},""},
{"errors if dividing by zero",{"4 0 /"},{},"divide by zero"},
{"errors if there is nothing on the stack",{"/"},{},"empty stack"},
{"errors if there is only one value on the stack",{"1 /"},{},"only one value on the stack"},
{"addition and subtraction",{"1 2 + 4 -"},{-1},""},
{"multiplication and division",{"2 4 * 3 /"},{2},""},
{"copies a value on the stack",{"1 dup"},{1,1},""},
{"copies the top value on the stack",{"1 2 dup"},{1,2,2},""},
{"errors if there is nothing on the stack",{"dup"},{},"empty stack"},
{"removes the top value on the stack if it is the only one",{"1 drop"},{},""},
{"removes the top value on the stack if it is not the only one",{"1 2 drop"},{1},""},
{"errors if there is nothing on the stack",{"drop"},{},"empty stack"},
{"swaps the top two values on the stack if they are the only ones",{"1 2 swap"},{2,1},""},
{"swaps the top two values on the stack if they are not the only ones",{"1 2 3 swap"},{1,3,2},""},
{"errors if there is nothing on the stack",{"swap"},{},"empty stack"},
{"errors if there is only one value on the stack",{"1 swap"},{},"only one value on the stack"},
{"copies the second element if there are only two",{"1 2 over"},{1,2,1},""},
{"copies the second element if there are more than two",{"1 2 3 over"},{1,2,3,2},""},
{"errors if there is nothing on the stack",{"over"},{},"empty stack"},
{"errors if there is only one value on the stack",{"1 over"},{},"only one value on the stack"},
{"can consist of built-in words",{": dup-twice dup dup ;","1 dup-twice"},{1,1,1},""},
{"final ; is optional",{": dup-twice dup dup","1 dup-twice"},{1,1,1},""},
{"two instructions on one line",{": dup-twice dup dup ; 1 dup-twice"},{1,1,1},""},
{"execute in the right order",{": countup 1 2 3 ;","countup"},{1,2,3},""},
{"two instructions on one line[2]",{": countup 1 2 3 ; countup"},{1,2,3},""},
{"can override other user-defined words",{": foo dup ;",": foo dup dup ;","1 foo"},{1,1,1},""},
{"three instructions on one line",{": foo dup ; : foo dup dup ; 1 foo"},{1,1,1},""},
{"can override built-in words",{": swap dup ;","1 swap"},{1,1},""},
{"two instructions on one line[3]",{": swap dup ; 1 swap"},{1,1},""},
{"can override built-in operators",{": + * ;","3 4 +"},{12},""},
{"two instructions on one line[4]",{": + * ; 3 4 +"},{12},""},
{"can use different words with the same name",{": foo 5 ;",": bar foo ;",": foo 6 ;","bar foo"},{5,6},""},
{"four instructions on one line",{": foo 5 ; : bar foo ; : foo 6 ; bar foo"},{5,6},""},
{"can define word that uses word with the same name",{": foo 10 ;",": foo foo 1 + ;","foo"},{11},""},
{"three instructions on one line[2]",{": foo 10 ;",": foo foo 1 + ;","foo"},{11},""},
{"cannot redefine non-negative numbers",{": 1 2 ;"},{},"illegal define:1"},
{"cannot redefine negative numbers",{": -1 2 ;"},{},"illegal define:-1"},
{"errors if executing a non-existent word",{"foo"},{},"undefined operation:foo"},
//test_equal("only defines locally",{{0},{2}},{evaluate({": + - ;", "1 1 +"}),evaluate({"1 1 +"})})
{"only defines locally[1]",{": + - ;","1 1 +"},{0},""},
{"only defines locally[2]",{"1 1 +"},{2},""},
{"DUP is case-insensitive",{"1 DUP Dup dup"},{1,1,1,1},""},
{"DROP is case-insensitive",{"1 2 3 4 DROP Drop drop"},{1},""},
{"SWAP is case-insensitive",{"1 2 SWAP 3 Swap 4 swap"},{2,3,4,1},""},
{"OVER is case-insensitive",{"1 2 OVER Over over"},{1,2,1,2,1},""},
{"user-defined words are case-insensitive",{": foo dup ;","1 FOO Foo foo"},{1,1,1,1},""},
{"definitions are case-insensitive",{": SWAP DUP Dup dup ;","1 swap"},{1,1,1,1},""}}

set_test_verbosity(TEST_SHOW_ALL)
--set_test_verbosity(TEST_SHOW_FAILED)
for t in tests do
    {string desc, sequence code, sequence expected, string msg} = t
    sequence actual = {}
    string amsg = ""
    try
        actual = forth(code)
    catch e
        amsg = e[E_USER]
    end try
    if (amsg=="") != (msg=="") then
        test_equal({actual,amsg},{expected,msg},desc)
    else
        test_equal(actual,expected,desc)
    end if
end for

test_summary()

